<!DOCTYPE html>
<html>
<head>
<link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" rel="stylesheet" type="text/css" />
<link href="https://maxcdn.bootstrapcdn.com/bootswatch/3.3.6/flatly/bootstrap.min.css" rel="stylesheet" type="text/css" />
<link href="https://cdn.datatables.net/1.10.10/css/jquery.dataTables.min.css" rel="stylesheet" type="text/css" />
<script src="https://code.jquery.com/jquery.min.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.4.2/angular.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular-ui-bootstrap/1.1.1/ui-bootstrap.min.js"></script>
<script src="https://cdn.datatables.net/1.10.10/js/jquery.dataTables.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.6/d3.min.js"></script>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<title>perfwhiz {{info.label}}</title>
<style type="text/css">
body {
  font: 12px sans-serif;
  padding-top: 50px;
}

.bar {
  fill: steelblue;
}
div.tooltip {
    position: absolute;
    border: 0px;
    pointer-events: none;
}
td {
  text-align: right;
}
th {
  text-align: right;
}
.legend {
  font-size: 12px;
}
.grid .tick {
    stroke: lightgrey;
    opacity: 0.7;
}
.axis path,
.axis line {
    fill: none;
    stroke: lightgray;
    stroke-width: 1;
    shape-rendering: crispEdges;
}

.grid .tick {
    stroke: lightgrey;
    stroke-opacity: 0;
    shape-rendering: crispEdges;
}
.grid path {
          stroke-width: 0;
}
</style>
</head>
<body ng-app="pw-heatmaps" ng-controller="PwHeatMapsCtrl">

<nav class="navbar navbar-default navbar-fixed-top">
  <div class="container-fluid">
      <div class="navbar-header">
      </div>
      <div class="collapse navbar-collapse">
           <ul class="nav navbar-nav">
                <li ng-repeat="mode in modes" ng-class="{active: current_index==$index}"
                    ng-click="handleEvent($event, $index)">
                    <a href="#">{[mode.title]}</a>
                </li>
          </ul>
      </div>
  </div>
</nav>

<div class="container-fluid">
    <h1><span class="glyphicon glyphicon-{[current_mode.icon]}" aria-hidden="true"></span> {[current_mode.title]}
     <small>{{info.label}} ({{info.window}} msec window)</small></h1>
</div>
<div class="container-fluid" ng-show="current_index == 0">
    <svg id="svg-coreloc" initsvg></svg>
    <svg id="svg-coreloc-legend"></svg>
</div>
<div class="container-fluid" ng-show="current_index == 1">
    <svg id="svg-swkvm"></svg>
</div>
<br><br>
<div class="container-fluid">
  <small>
    Crafted on {{info.date}} by <a href="https://github.com/cisco-oss-eng/perfwhiz">perfwhiz</a> {{info.version}}
  </small>
</div>

<script>
var max_cores = {{info.max_cores}};
var swk_events = {{swk_events}};

var total_width = 1100;
var grid_color = "#bbbbbb";

// Generic code below
var div = d3.select("body").append("div")
    .attr("class", "tooltip")
    .style("opacity", 0);
var total_height = 800;

// approximate left margin required based on longest task name
var margin = {top: 30, right: 30, bottom: 40, left: 30},
    width = total_width - margin.left - margin.right,
    height = total_height - margin.top - margin.bottom;

var y = d3.scale.ordinal()
    .rangeRoundBands([height, 0], 0.1);

var yAxis = d3.svg.axis()
    .scale(y)
    .orient("left");

function draw_line(svg, x1, y1, x2, y2, color) {
    svg.append("line")
        .attr("x1", x1)
        .attr("y1", y1)
        .attr("x2", x2)
        .attr("y2", y2)
        .attr("stroke-width", 1)
        .attr("stroke", color);
}
function draw_vert_line(svg, x, y1, y2, color) {
    draw_line(svg, x, y1, x, y2, color);
}
function draw_hor_line(svg, x1, x2, y, color) {
    draw_line(svg, x1, y, x2, y, color);
}
function get_legend_text_width(text_list) {
    // a fake svg to calculate max rendered width
    var tmp_svg = d3.select("body").append("svg").attr("width", 1000).attr("height", 400);
    var tmp_lg = tmp_svg.append("g").attr("class", "g");
    var max_width = 0;
    tmp_lg.selectAll("text")
        .data(text_list)
        .enter().append("text")
        .text(function (d, i) { return d;});
    tmp_lg.selectAll("text")
        .each(function() {
          max_width = Math.max(this.getBBox().width, max_width);
        });
    tmp_svg.remove();
    return max_width;
}

function draw_legend(svg, text_list, color_list, width, align, margin, columns) {
    var inner_margin = 5;
    var color_rect_size = 18;
    var inner_gap = 2;
    var row_height = color_rect_size + inner_gap;
    // calculate the width of the legend box
    var count = text_list.length;
    var col_width = get_legend_text_width(text_list) + color_rect_size + inner_gap * 2;
    columns = Math.min(count, columns);
    var lb_width = (col_width * columns) + 2 * inner_margin;
    // calculate the x coordinates of the legend box based
    if (align == "left") {
        lb_x = margin;
    } else if (align == "center") {
        lb_x = width/2 - lb_width/2;
    } else {
        lb_x = width - margin - lb_width;
    }
    var count_per_column = Math.ceil(count / columns);
    var lb_height = count_per_column * row_height + inner_margin * 2 - inner_gap;
    var lbg = svg.append("g")
        .attr("class", "g")
        .attr("id", "legend_group")
        .attr("transform", "translate(" + lb_x + ", 0)");
    var legend_box = lbg.append("rect").
        attr("id","legend_box")
        .attr("height", lb_height)
        .attr("width", lb_width)
        .style("stroke-width", 1)
        .style("stroke", "#bbbbbb")
        .style("fill-opacity", 0.7)
        .style("fill", "white");
    var legend = lbg.selectAll(".legend")
        .data(color_list)
        .enter().append("g")
        .attr("class", "legend")
        .attr("transform", function(d, i) {
            return "translate(" +
                    (inner_margin + col_width * Math.floor(i/count_per_column)) +
                    "," +
                    (inner_margin + row_height * (i % count_per_column)) + ")"; });
    legend.append("rect")
        .attr("width", color_rect_size)
        .attr("height", color_rect_size)
        .style("opacity", 0.8)
        .style("fill", function(d, i) { return d; });
    legend.append("text")
        .attr('class','legend')
        .attr("x", row_height)
        .attr("dy", "1.2em")
        .style("text-anchor", "start")
        .text(function(d, i) { return text_list[i]; });
    var max_width = get_legend_text_width(text_list);
}
// ----- KVM EXIT TYPES COUNT CHART
function get_text_width(text_list) {
    // a fake svg to calculate max rendered width
    var tmp_svg = d3.select("body").append("svg").attr("width", 1000).attr("height", 400);
    var tmp_lg = tmp_svg.append("g").attr("class", "g");
    var max_width = 0;
    tmp_lg.selectAll("text")
        .data(text_list)
        .enter().append("text")
        .text(function (d, i) { return d;});
    tmp_lg.selectAll("text")
        .each(function() {
          max_width = Math.max(this.getBBox().width, max_width);
        });
    tmp_svg.remove();
    return max_width;
}

// ----- Context Switches and KVM events heatmaps
function draw_swkvm(scope) {
/*
    var xcpu = d3.scale.linear()
        .rangeRound([0, width - 120]);
    var xsw = d3.scale.linear()
        .rangeRound([0, width - 120]);
    var xCpuAxis = d3.svg.axis()
        .scale(xcpu)
        .orient("top")
        .tickFormat(d3.format("%"));
    var xSwAxis = d3.svg.axis()
        .scale(xsw)
        .orient("bottom")
        .tickFormat(d3.format(".2s"));

    var svg = d3.select("#svg-cpu")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    y.domain(task_data.map(function(d) { return d.task; }));
    var max_sw = d3.max(task_data, function(d) { return d.sw; })
    var round_unit = Math.pow(10, Math.round(Math.log10(max_sw)))
    max_sw = Math.max(10, Math.ceil(max_sw/round_unit)*round_unit);
    xcpu.domain([0, 1]);
    xsw.domain([0, max_sw]);
    var sw_color = "#cb181d"; // red
    // get a set of all starting (max) 3 letter strings for task names
    var task_color_keys = task_data.map(function(d) { return d.task.substring(0, 3); })
    var task_color_key = d3.scale.ordinal().domain(task_color_keys).range(d3.range(20));
    var task_color = d3.scale.category20()
    var axis = svg.append("g")
        .attr("class", "x axis")
        .call(xCpuAxis);
    axis
        .append("text")
        .attr("x", width - 24)
        .style("text-anchor", "end")
        .text("% one core");
    axis
        .append("rect")
        .attr("x", width - 20)
        .attr("y", -18)
        .attr("width", 20)
        .attr("height", 20)
        .style("opacity", 0.8)
        .style("fill", task_color(0));
    axis = svg.append("g")
        .attr("class", "x axis")
        .attr("transform", "translate(0," + height + ")")
        .call(xSwAxis);
    axis
        .append("text")
        .attr("x", width - 24)
        .style("text-anchor", "end")
        .text("context switches");
    axis
        .append("circle")
        .attr("r", 6)
        .attr("cx", width - 14)
        .attr("cy", -4)
        .style("opacity", 0.6)
        .style("fill", sw_color);

    svg.append("g")
        .attr("class", "y axis")
        .call(yAxis);

    [0.5, 1].forEach(function (pct) { draw_vert_line(svg, xcpu(pct), 0, height, grid_color); });

    var state = svg.selectAll(".g")
        .data(task_data)
        .enter().append("g")
        .attr("class", "g")
        .attr("transform", function(d) { return "translate(0, " + y(d.task) + ")"; });
    state
        .append("rect")
        .attr("height", y.rangeBand())
        .attr("x", 0)
        .attr("width", function(d) { return xcpu(d.cpu/100); })
        .style("opacity", 0.4)
        .style("fill", function(d) { return task_color(task_color_key(d.task.substring(0,3)));})
        .on("mouseover", function(d) {
            div.transition()
                .duration(200)
                .style("opacity", 0.8);
            var matrix = this.getScreenCTM()
                .translate(+this.getAttribute("cx"),
                           +this.getAttribute("cy"));
            div	.html('<ul class="list-group"><li class="list-group-item"><b>' +  d.task + '</b><br>one core usage&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="badge">'+ d.cpu + '%</span></li>')
                .style("top", (window.pageYOffset + matrix.f + y.rangeBand()/2 - 40) + "px")
                .style("left", (d3.event.pageX) + "px");
            d3.select(this).style("opacity", 1);
        })
        .on("mousemove", function(d) {
            div	.style("left", (d3.event.pageX) + "px");
        })
        .on("mouseout", function(d) {
            div.transition()
                .duration(500)
                .style("opacity", 0);
            d3.select(this).style("opacity", 0.4);
        });
    state
        .append("rect")
        .attr("height", 1)
        .attr("x", 0)
        .attr("y", (y.rangeBand()/2))
        .attr("width", function(d) { return Math.max(0, xsw(d.sw) - 6); })
        .style("opacity", 0.9)
        .style("fill", sw_color);
    state
        .append("circle")
        .attr("r", 6)
        .attr("cx", function(d) { return xsw(d.sw); })
        .attr("cy", (y.rangeBand()/2))
        .style("opacity", 0.9)
        .style("fill", sw_color)
        .on("mouseover", function(d) {
            div.transition()
                .duration(100)
                .style("opacity", 1);
            var matrix = this.getScreenCTM()
                .translate(+this.getAttribute("cx"),
                           +this.getAttribute("cy"));
            div	.html('<ul class="list-group"><li class="list-group-item"><b>' +  d.task + '</b><br>context switches &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="badge">'+ d.sw + '</span></li>')
                .style("top", (window.pageYOffset + matrix.f + y.rangeBand()/2 - 50) + "px")
                .style("left", (d3.event.pageX) + "px");
        })
        .on("mouseout", function(d) {
            div.transition()
                .duration(500)
                .style("opacity", 0);
            d3.select(this).style("opacity", 0.9);
        });
*/
}

function draw_right_arrow(node, x, y, h, w, color) {
    var data = [[x, y-h/2], [x+w, y], [x, y+h/2]];
    var line = d3.svg.line()
                 .x(function(d) { return d[0];})
                 .y(function(d) { return d[1];})
                 .interpolate("linear");
    node.append("path")
        .attr("d", line(data))
        .style("stroke", color)
        .style("fill", color);
    node.append("path")
        .attr("d", line([[x-w*3,y], [x,y]]))
        .style("stroke", color)
        .style("stroke-width", 3)
        .style("fill", color);
}
var si_fmt = d3.format("s");
function usec_format(usec) {
    return si_fmt(usec/1000000)+"s";
}
var color = d3.scale.category20();
function get_task_color(index) {
    return color(index % 20);
}

// ----- Coremap
function draw_coreloc(scope) {
    var x = d3.scale.linear()
        .range([0, width]);
    var xAxis = d3.svg.axis()
        .scale(x)
        .orient("bottom")
        .tickFormat(usec_format)
        .tickSize(-height, 0, 0);

    x.domain([swk_events.usecs_min, swk_events.usecs_max]);
    var y = d3.scale.ordinal()
        .rangeBands([height, 0], 0.01, 0.5);
    var yAxis = d3.svg.axis()
        .scale(y)
        .orient("left")
        .tickSize(-width, 0, -width);
    var core_range = d3.range(max_cores);
    y.domain(core_range);

    var svg = d3.select("#svg-coreloc")
                .attr("width", width + margin.left + margin.right)
                .attr("height", total_height)
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
    var axis = svg.append("g")
        .attr("class", "x axis")
        .attr("transform", "translate(0," + height + ")")
        .call(xAxis);
    axis
        .append("text")
        .attr("x", width-28)
        .attr("dy", "2em")
        .style("text-anchor", "middle")
        .text("time");
    draw_right_arrow(axis, width-10, 30, 10, 10, "red");
    svg.append("g")
        .attr("class", "y axis")
        .call(yAxis);
    var yAxis2 = d3.svg.axis()
        .scale(y)
        .orient("right")
        .tickSize(0, 0, 0);
    var axis = svg.append("g")
        .attr("class", "y axis")
        .attr("transform", "translate(" + (width) + ",0)")
        .call(yAxis2);
    var event_height = y.rangeBand() / 2;
    var y_offset = event_height / 2;
    var state = svg.selectAll(".state")
        .data(swk_events.task_events)
        .enter().append("g")
        .attr("class", "g")
        .attr("id", function(d, i) {d.color=get_task_color(i); return d.task;});
    state
        .selectAll("rect")
        // events is a list of [usec, duration, cpu] triplets
        .data(function(d) {return d.events['sched__sched_switch'];})
        .enter().append("rect")
        .attr("x", function(d) { var x0 = x((d[0] - d[1])); if (x0 < 0) { x0 = 0;} return x0;})
        .attr("y", function(d) { return y(d[2]) + y_offset;})
        .attr("height", event_height)
        .attr("width", function(d) { var x0 = x((d[0] - d[1])); if (x0 < 0) { x0 = 0;}  return x(d[0]) - x0;})
        .style("opacity", 0.5)
        .style("fill", function(d) { return this.parentNode.__data__.color;})
        .on("mouseover", function(d) {
            div.transition()
                .duration(100)
                .style("opacity", 1);
            var matrix = this.getScreenCTM()
                .translate(+this.getAttribute("x"),
                           +this.getAttribute("y"));
            div	.html('<button class="btn btn-primary" type="button">' + this.parentNode.__data__.task +
                      '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="badge">'+ d[1] + ' usec</span></button>')
                .style("top", (window.pageYOffset + matrix.f + y.rangeBand()/2 - 40) + "px")
                .style("left", (d3.event.pageX) + "px");
        })
        .on("mousemove", function(d) {
            div	.style("left", (d3.event.pageX) + "px");
        })
        .on("mouseout", function(d) {
            div.transition()
                .duration(500)
                .style("opacity", 0);
            d3.select(this).style("opacity", 0.5);
        });
    var text_list = swk_events.task_events.map(function(d) {return d.task;});
    var color_list = swk_events.task_events.map(function(d, i) {return get_task_color(i);});
    var lg_svg = d3.select("#svg-coreloc-legend")
                        .attr("width", width + margin.left + margin.right);
    draw_legend(lg_svg, text_list, color_list, width, "center", 0, 5)
}

var app = angular.module('pw-heatmaps', ['ui.bootstrap']);
var modes = [
    {title:"Core locality over time", icon:"globe", svg:"coreloc", init:draw_coreloc},
//    {title:"Context switches and KVM events Heatmap", icon:"option-horizontal", svg:"swkvm", init:draw_swkvm}
];
app.config(['$interpolateProvider', function($interpolateProvider) {
  $interpolateProvider.startSymbol('{[');
  $interpolateProvider.endSymbol(']}');
}]);
app.controller('PwHeatMapsCtrl', PwHeatMapsCtrl);
app.directive('initsvg', function() {
    return {
        link: function($scope, element, attrs) {
            // Trigger when number of children changes,
            // including by directives like ng-repeat
            var watch = $scope.$watch(function() {
                return element.children().length;
            }, function() {
                // Wait for templates to render
                $scope.$evalAsync(function() {
                    // Finally, directives are evaluated
                    // and templates are renderer here
                    $scope.handleEvent(null, 0);
                });
            });
        },
    };
});

function PwHeatMapsCtrl($scope) {
    $scope.task_list = swk_events.task_events.map(function(d) { return d.task; });
    $scope.coreloc_state = $scope.task_list.map(function(d) { return false; });
    $scope.current_index = 0

    $scope.modes = modes;
    $scope.handleEvent = function(event, index) {
        $scope.current_index = index;
        $scope.current_mode = $scope.modes[index];
        var initf = $scope.current_mode['init'];
        if (initf != null) {
            initf($scope);
            $scope.current_mode['init'] = null;
        }
    };
}
</script>

</body>
</html>